{"ast":null,"code":"import maxBy from 'lodash/maxBy';\nimport minBy from 'lodash/minBy';\nimport kebabCase from 'lodash/kebabCase';\nimport ownerDocument from 'dom-lib/ownerDocument';\nimport getOffset from 'dom-lib/getOffset';\nimport scrollTop from 'dom-lib/scrollTop';\nimport scrollLeft from 'dom-lib/scrollLeft';\nimport _getPosition from 'dom-lib/getPosition';\nimport getStyle from 'dom-lib/getStyle';\nimport nodeName from 'dom-lib/nodeName';\nexport var AutoPlacement = {\n  left: 'Start',\n  right: 'End',\n  top: 'Start',\n  bottom: 'End'\n};\n/**\r\n * Get the external dimensions of the container\r\n * @param containerNode\r\n */\n\nfunction getContainerDimensions(containerNode) {\n  var width;\n  var height;\n  var scrollX;\n  var scrollY;\n\n  if (containerNode.tagName === 'BODY') {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    scrollY = scrollTop(ownerDocument(containerNode).documentElement) || scrollTop(containerNode);\n    scrollX = scrollLeft(ownerDocument(containerNode).documentElement) || scrollLeft(containerNode);\n  } else {\n    var _ref = getOffset(containerNode);\n\n    width = _ref.width;\n    height = _ref.height;\n    scrollY = scrollTop(containerNode);\n    scrollX = scrollLeft(containerNode);\n  }\n\n  return {\n    width: width,\n    height: height,\n    scrollX: scrollX,\n    scrollY: scrollY\n  };\n}\n\nexport default (function (props) {\n  var placement = props.placement,\n      preventOverflow = props.preventOverflow,\n      padding = props.padding;\n\n  function getTopDelta(top, overlayHeight, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n\n    var containerDimensions = getContainerDimensions(container);\n    var containerHeight = containerDimensions.height,\n        scrollY = containerDimensions.scrollY;\n    var topEdgeOffset = top - padding - scrollY;\n    var bottomEdgeOffset = top + padding + overlayHeight - scrollY;\n\n    if (topEdgeOffset < 0) {\n      return -topEdgeOffset;\n    } else if (bottomEdgeOffset > containerHeight) {\n      return containerHeight - bottomEdgeOffset;\n    }\n\n    return 0;\n  }\n\n  function getLeftDelta(left, overlayWidth, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n\n    var containerDimensions = getContainerDimensions(container);\n    var scrollX = containerDimensions.scrollX,\n        containerWidth = containerDimensions.width;\n    var leftEdgeOffset = left - padding - scrollX;\n    var rightEdgeOffset = left + padding + overlayWidth - scrollX;\n\n    if (leftEdgeOffset < 0) {\n      return -leftEdgeOffset;\n    } else if (rightEdgeOffset > containerWidth) {\n      return containerWidth - rightEdgeOffset;\n    }\n\n    return 0;\n  }\n\n  function getPositionTop(container, overlayHeight, top) {\n    if (!preventOverflow) {\n      return top;\n    }\n\n    var _getContainerDimensio = getContainerDimensions(container),\n        scrollY = _getContainerDimensio.scrollY,\n        containerHeight = _getContainerDimensio.height; // 判断 overlay 底部是否溢出，设置 top\n\n\n    if (overlayHeight + top > containerHeight + scrollY) {\n      return containerHeight - overlayHeight + scrollY;\n    } // top 的最小值不能少于纵向滚动条 y 的值\n\n\n    return Math.max(scrollY, top);\n  }\n\n  function getPositionLeft(container, overlayWidth, left) {\n    if (!preventOverflow) {\n      return left;\n    }\n\n    var _getContainerDimensio2 = getContainerDimensions(container),\n        scrollX = _getContainerDimensio2.scrollX,\n        containerWidth = _getContainerDimensio2.width;\n\n    if (overlayWidth + left > containerWidth + scrollX) {\n      return containerWidth - overlayWidth + scrollX;\n    } // left 的最小值不能少于横向滚动条 x 的值\n\n\n    return Math.max(scrollX, left);\n  }\n\n  return {\n    getPosition: function getPosition(target, container) {\n      var offset = container.tagName === 'BODY' ? getOffset(target) : _getPosition(target, container, false);\n      return offset;\n    },\n    getCursorOffsetPosition: function getCursorOffsetPosition(target, container, cursorPosition) {\n      var left = cursorPosition.left,\n          top = cursorPosition.top,\n          clientLeft = cursorPosition.clientLeft,\n          clientTop = cursorPosition.clientTop;\n      var offset = {\n        left: left,\n        top: top,\n        width: 10,\n        height: 10\n      };\n\n      if (getStyle(target, 'position') === 'fixed') {\n        offset.left = clientLeft;\n        offset.top = clientTop;\n        return offset;\n      }\n\n      if (container.tagName === 'BODY') {\n        return offset;\n      }\n\n      var containerOffset = {\n        top: 0,\n        left: 0\n      };\n\n      if (nodeName(container) !== 'html') {\n        var nextParentOffset = getOffset(container);\n\n        if (nextParentOffset) {\n          containerOffset.top = nextParentOffset.top;\n          containerOffset.left = nextParentOffset.left;\n        }\n      }\n\n      containerOffset.top += parseInt(getStyle(container, 'borderTopWidth'), 10) - scrollTop(container) || 0;\n      containerOffset.left += parseInt(getStyle(container, 'borderLeftWidth'), 10) - scrollLeft(container) || 0;\n      offset.left = left - containerOffset.left;\n      offset.top = top - containerOffset.top;\n      return offset;\n    },\n    calcAutoPlacement: function calcAutoPlacement(targetOffset, container, overlay) {\n      var _getContainerDimensio3 = getContainerDimensions(container),\n          width = _getContainerDimensio3.width,\n          height = _getContainerDimensio3.height,\n          scrollX = _getContainerDimensio3.scrollX,\n          scrollY = _getContainerDimensio3.scrollY;\n\n      var left = targetOffset.left - scrollX - overlay.width;\n      var top = targetOffset.top - scrollY - overlay.height;\n      var right = width - targetOffset.left - targetOffset.width + scrollX - overlay.width;\n      var bottom = height - targetOffset.top - targetOffset.height + scrollY - overlay.height;\n      var horizontal = [{\n        key: 'left',\n        value: left\n      }, {\n        key: 'right',\n        value: right\n      }];\n      var vertical = [{\n        key: 'top',\n        value: top\n      }, {\n        key: 'bottom',\n        value: bottom\n      }];\n      var AV = 'autoVertical';\n      var AH = 'autoHorizontal';\n      var direction;\n      var align;\n\n      if (placement.indexOf(AV) !== -1) {\n        direction = maxBy(vertical, function (o) {\n          return o.value;\n        });\n        return placement === AV ? direction.key : \"\" + direction.key + placement.replace(AV, '');\n      } else if (placement.indexOf(AH) !== -1) {\n        direction = maxBy(horizontal, function (o) {\n          return o.value;\n        });\n        return placement === AH ? direction.key : \"\" + direction.key + placement.replace(AH, '');\n      }\n      /**\r\n       * Precedence Vertical\r\n       * [...vertical, ...horizontal]\r\n       */\n\n\n      direction = maxBy([].concat(vertical, horizontal), function (o) {\n        return o.value;\n      });\n\n      if (direction.key === 'left' || direction.key === 'right') {\n        align = minBy(vertical, function (o) {\n          return o.value;\n        });\n      } else {\n        align = minBy(horizontal, function (o) {\n          return o.value;\n        });\n      }\n\n      return \"\" + direction.key + AutoPlacement[align.key];\n    },\n    // Calculate the position of the overlay\n    calcOverlayPosition: function calcOverlayPosition(overlayNode, target, container, cursorPosition) {\n      var childOffset = cursorPosition ? this.getCursorOffsetPosition(target, container, cursorPosition) : this.getPosition(target, container);\n\n      var _ref2 = getOffset(overlayNode),\n          overlayHeight = _ref2.height,\n          overlayWidth = _ref2.width;\n\n      var top = childOffset.top,\n          left = childOffset.left;\n      var nextPlacement = placement;\n\n      if (placement && placement.indexOf('auto') >= 0) {\n        nextPlacement = this.calcAutoPlacement(childOffset, container, {\n          height: overlayHeight,\n          width: overlayWidth\n        });\n      }\n\n      var positionLeft;\n      var positionTop;\n      var arrowOffsetLeft;\n      var arrowOffsetTop;\n\n      if (nextPlacement === 'left' || nextPlacement === 'right') {\n        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;\n        var topDelta = getTopDelta(positionTop, overlayHeight, container);\n        positionTop += topDelta;\n        arrowOffsetTop = 50 * (1 - 2 * topDelta / overlayHeight) + \"%\";\n        arrowOffsetLeft = undefined;\n      } else if (nextPlacement === 'top' || nextPlacement === 'bottom') {\n        positionLeft = left + (childOffset.width - overlayWidth) / 2;\n        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container);\n        positionLeft += leftDelta;\n        arrowOffsetLeft = 50 * (1 - 2 * leftDelta / overlayWidth) + \"%\";\n        arrowOffsetTop = undefined;\n      }\n\n      if (nextPlacement === 'top' || nextPlacement === 'topStart' || nextPlacement === 'topEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top - overlayHeight);\n      }\n\n      if (nextPlacement === 'bottom' || nextPlacement === 'bottomStart' || nextPlacement === 'bottomEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top + childOffset.height);\n      }\n\n      if (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left - overlayWidth);\n      }\n\n      if (nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left + childOffset.width);\n      }\n\n      if (document.dir === 'rtl' && (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd' || nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd')) {\n        /**\r\n         * When laying out in rtl, if the width of the container\r\n         * is less than the width of the container scrolling,\r\n         * you need to recalculate the left value.\r\n         */\n        var _getContainerDimensio4 = getContainerDimensions(container),\n            containerWidth = _getContainerDimensio4.width;\n\n        if (container.scrollWidth > containerWidth) {\n          positionLeft = containerWidth + positionLeft - container.scrollWidth;\n        }\n      }\n\n      if (nextPlacement === 'topStart' || nextPlacement === 'bottomStart') {\n        if (document.dir === 'rtl') {\n          var nextLeft = left + (childOffset.width - overlayWidth);\n          positionLeft = nextLeft + getLeftDelta(nextLeft, overlayWidth, container);\n        } else {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        }\n      }\n\n      if (nextPlacement === 'topEnd' || nextPlacement === 'bottomEnd') {\n        if (document.dir === 'rtl') {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        } else {\n          var _nextLeft = left + (childOffset.width - overlayWidth);\n\n          positionLeft = _nextLeft + getLeftDelta(_nextLeft, overlayWidth, container);\n        }\n      }\n\n      if (nextPlacement === 'leftStart' || nextPlacement === 'rightStart') {\n        positionTop = top + getTopDelta(top, overlayHeight, container);\n      }\n\n      if (nextPlacement === 'leftEnd' || nextPlacement === 'rightEnd') {\n        var nextTop = top + (childOffset.height - overlayHeight);\n        positionTop = nextTop + getTopDelta(nextTop, overlayHeight, container);\n      }\n\n      return {\n        positionLeft: positionLeft,\n        positionTop: positionTop,\n        arrowOffsetLeft: arrowOffsetLeft,\n        arrowOffsetTop: arrowOffsetTop,\n        positionClassName: \"placement-\" + kebabCase(nextPlacement)\n      };\n    }\n  };\n});","map":{"version":3,"names":["maxBy","minBy","kebabCase","ownerDocument","getOffset","scrollTop","scrollLeft","_getPosition","getStyle","nodeName","AutoPlacement","left","right","top","bottom","getContainerDimensions","containerNode","width","height","scrollX","scrollY","tagName","window","innerWidth","innerHeight","documentElement","_ref","props","placement","preventOverflow","padding","getTopDelta","overlayHeight","container","containerDimensions","containerHeight","topEdgeOffset","bottomEdgeOffset","getLeftDelta","overlayWidth","containerWidth","leftEdgeOffset","rightEdgeOffset","getPositionTop","_getContainerDimensio","Math","max","getPositionLeft","_getContainerDimensio2","getPosition","target","offset","getCursorOffsetPosition","cursorPosition","clientLeft","clientTop","containerOffset","nextParentOffset","parseInt","calcAutoPlacement","targetOffset","overlay","_getContainerDimensio3","horizontal","key","value","vertical","AV","AH","direction","align","indexOf","o","replace","concat","calcOverlayPosition","overlayNode","childOffset","_ref2","nextPlacement","positionLeft","positionTop","arrowOffsetLeft","arrowOffsetTop","topDelta","undefined","leftDelta","document","dir","_getContainerDimensio4","scrollWidth","nextLeft","_nextLeft","nextTop","positionClassName"],"sources":["C:/Users/jaink/OneDrive/Desktop/New folder (4)/chameleon-website/node_modules/rsuite/esm/Overlay/positionUtils.js"],"sourcesContent":["import maxBy from 'lodash/maxBy';\r\nimport minBy from 'lodash/minBy';\r\nimport kebabCase from 'lodash/kebabCase';\r\nimport ownerDocument from 'dom-lib/ownerDocument';\r\nimport getOffset from 'dom-lib/getOffset';\r\nimport scrollTop from 'dom-lib/scrollTop';\r\nimport scrollLeft from 'dom-lib/scrollLeft';\r\nimport _getPosition from 'dom-lib/getPosition';\r\nimport getStyle from 'dom-lib/getStyle';\r\nimport nodeName from 'dom-lib/nodeName';\r\nexport var AutoPlacement = {\r\n  left: 'Start',\r\n  right: 'End',\r\n  top: 'Start',\r\n  bottom: 'End'\r\n};\r\n\r\n/**\r\n * Get the external dimensions of the container\r\n * @param containerNode\r\n */\r\nfunction getContainerDimensions(containerNode) {\r\n  var width;\r\n  var height;\r\n  var scrollX;\r\n  var scrollY;\r\n\r\n  if (containerNode.tagName === 'BODY') {\r\n    width = window.innerWidth;\r\n    height = window.innerHeight;\r\n    scrollY = scrollTop(ownerDocument(containerNode).documentElement) || scrollTop(containerNode);\r\n    scrollX = scrollLeft(ownerDocument(containerNode).documentElement) || scrollLeft(containerNode);\r\n  } else {\r\n    var _ref = getOffset(containerNode);\r\n\r\n    width = _ref.width;\r\n    height = _ref.height;\r\n    scrollY = scrollTop(containerNode);\r\n    scrollX = scrollLeft(containerNode);\r\n  }\r\n\r\n  return {\r\n    width: width,\r\n    height: height,\r\n    scrollX: scrollX,\r\n    scrollY: scrollY\r\n  };\r\n}\r\n\r\nexport default (function (props) {\r\n  var placement = props.placement,\r\n      preventOverflow = props.preventOverflow,\r\n      padding = props.padding;\r\n\r\n  function getTopDelta(top, overlayHeight, container) {\r\n    if (!preventOverflow) {\r\n      return 0;\r\n    }\r\n\r\n    var containerDimensions = getContainerDimensions(container);\r\n    var containerHeight = containerDimensions.height,\r\n        scrollY = containerDimensions.scrollY;\r\n    var topEdgeOffset = top - padding - scrollY;\r\n    var bottomEdgeOffset = top + padding + overlayHeight - scrollY;\r\n\r\n    if (topEdgeOffset < 0) {\r\n      return -topEdgeOffset;\r\n    } else if (bottomEdgeOffset > containerHeight) {\r\n      return containerHeight - bottomEdgeOffset;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function getLeftDelta(left, overlayWidth, container) {\r\n    if (!preventOverflow) {\r\n      return 0;\r\n    }\r\n\r\n    var containerDimensions = getContainerDimensions(container);\r\n    var scrollX = containerDimensions.scrollX,\r\n        containerWidth = containerDimensions.width;\r\n    var leftEdgeOffset = left - padding - scrollX;\r\n    var rightEdgeOffset = left + padding + overlayWidth - scrollX;\r\n\r\n    if (leftEdgeOffset < 0) {\r\n      return -leftEdgeOffset;\r\n    } else if (rightEdgeOffset > containerWidth) {\r\n      return containerWidth - rightEdgeOffset;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function getPositionTop(container, overlayHeight, top) {\r\n    if (!preventOverflow) {\r\n      return top;\r\n    }\r\n\r\n    var _getContainerDimensio = getContainerDimensions(container),\r\n        scrollY = _getContainerDimensio.scrollY,\r\n        containerHeight = _getContainerDimensio.height; // 判断 overlay 底部是否溢出，设置 top\r\n\r\n\r\n    if (overlayHeight + top > containerHeight + scrollY) {\r\n      return containerHeight - overlayHeight + scrollY;\r\n    } // top 的最小值不能少于纵向滚动条 y 的值\r\n\r\n\r\n    return Math.max(scrollY, top);\r\n  }\r\n\r\n  function getPositionLeft(container, overlayWidth, left) {\r\n    if (!preventOverflow) {\r\n      return left;\r\n    }\r\n\r\n    var _getContainerDimensio2 = getContainerDimensions(container),\r\n        scrollX = _getContainerDimensio2.scrollX,\r\n        containerWidth = _getContainerDimensio2.width;\r\n\r\n    if (overlayWidth + left > containerWidth + scrollX) {\r\n      return containerWidth - overlayWidth + scrollX;\r\n    } // left 的最小值不能少于横向滚动条 x 的值\r\n\r\n\r\n    return Math.max(scrollX, left);\r\n  }\r\n\r\n  return {\r\n    getPosition: function getPosition(target, container) {\r\n      var offset = container.tagName === 'BODY' ? getOffset(target) : _getPosition(target, container, false);\r\n      return offset;\r\n    },\r\n    getCursorOffsetPosition: function getCursorOffsetPosition(target, container, cursorPosition) {\r\n      var left = cursorPosition.left,\r\n          top = cursorPosition.top,\r\n          clientLeft = cursorPosition.clientLeft,\r\n          clientTop = cursorPosition.clientTop;\r\n      var offset = {\r\n        left: left,\r\n        top: top,\r\n        width: 10,\r\n        height: 10\r\n      };\r\n\r\n      if (getStyle(target, 'position') === 'fixed') {\r\n        offset.left = clientLeft;\r\n        offset.top = clientTop;\r\n        return offset;\r\n      }\r\n\r\n      if (container.tagName === 'BODY') {\r\n        return offset;\r\n      }\r\n\r\n      var containerOffset = {\r\n        top: 0,\r\n        left: 0\r\n      };\r\n\r\n      if (nodeName(container) !== 'html') {\r\n        var nextParentOffset = getOffset(container);\r\n\r\n        if (nextParentOffset) {\r\n          containerOffset.top = nextParentOffset.top;\r\n          containerOffset.left = nextParentOffset.left;\r\n        }\r\n      }\r\n\r\n      containerOffset.top += parseInt(getStyle(container, 'borderTopWidth'), 10) - scrollTop(container) || 0;\r\n      containerOffset.left += parseInt(getStyle(container, 'borderLeftWidth'), 10) - scrollLeft(container) || 0;\r\n      offset.left = left - containerOffset.left;\r\n      offset.top = top - containerOffset.top;\r\n      return offset;\r\n    },\r\n    calcAutoPlacement: function calcAutoPlacement(targetOffset, container, overlay) {\r\n      var _getContainerDimensio3 = getContainerDimensions(container),\r\n          width = _getContainerDimensio3.width,\r\n          height = _getContainerDimensio3.height,\r\n          scrollX = _getContainerDimensio3.scrollX,\r\n          scrollY = _getContainerDimensio3.scrollY;\r\n\r\n      var left = targetOffset.left - scrollX - overlay.width;\r\n      var top = targetOffset.top - scrollY - overlay.height;\r\n      var right = width - targetOffset.left - targetOffset.width + scrollX - overlay.width;\r\n      var bottom = height - targetOffset.top - targetOffset.height + scrollY - overlay.height;\r\n      var horizontal = [{\r\n        key: 'left',\r\n        value: left\r\n      }, {\r\n        key: 'right',\r\n        value: right\r\n      }];\r\n      var vertical = [{\r\n        key: 'top',\r\n        value: top\r\n      }, {\r\n        key: 'bottom',\r\n        value: bottom\r\n      }];\r\n      var AV = 'autoVertical';\r\n      var AH = 'autoHorizontal';\r\n      var direction;\r\n      var align;\r\n\r\n      if (placement.indexOf(AV) !== -1) {\r\n        direction = maxBy(vertical, function (o) {\r\n          return o.value;\r\n        });\r\n        return placement === AV ? direction.key : \"\" + direction.key + placement.replace(AV, '');\r\n      } else if (placement.indexOf(AH) !== -1) {\r\n        direction = maxBy(horizontal, function (o) {\r\n          return o.value;\r\n        });\r\n        return placement === AH ? direction.key : \"\" + direction.key + placement.replace(AH, '');\r\n      }\r\n      /**\r\n       * Precedence Vertical\r\n       * [...vertical, ...horizontal]\r\n       */\r\n\r\n\r\n      direction = maxBy([].concat(vertical, horizontal), function (o) {\r\n        return o.value;\r\n      });\r\n\r\n      if (direction.key === 'left' || direction.key === 'right') {\r\n        align = minBy(vertical, function (o) {\r\n          return o.value;\r\n        });\r\n      } else {\r\n        align = minBy(horizontal, function (o) {\r\n          return o.value;\r\n        });\r\n      }\r\n\r\n      return \"\" + direction.key + AutoPlacement[align.key];\r\n    },\r\n    // Calculate the position of the overlay\r\n    calcOverlayPosition: function calcOverlayPosition(overlayNode, target, container, cursorPosition) {\r\n      var childOffset = cursorPosition ? this.getCursorOffsetPosition(target, container, cursorPosition) : this.getPosition(target, container);\r\n\r\n      var _ref2 = getOffset(overlayNode),\r\n          overlayHeight = _ref2.height,\r\n          overlayWidth = _ref2.width;\r\n\r\n      var top = childOffset.top,\r\n          left = childOffset.left;\r\n      var nextPlacement = placement;\r\n\r\n      if (placement && placement.indexOf('auto') >= 0) {\r\n        nextPlacement = this.calcAutoPlacement(childOffset, container, {\r\n          height: overlayHeight,\r\n          width: overlayWidth\r\n        });\r\n      }\r\n\r\n      var positionLeft;\r\n      var positionTop;\r\n      var arrowOffsetLeft;\r\n      var arrowOffsetTop;\r\n\r\n      if (nextPlacement === 'left' || nextPlacement === 'right') {\r\n        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;\r\n        var topDelta = getTopDelta(positionTop, overlayHeight, container);\r\n        positionTop += topDelta;\r\n        arrowOffsetTop = 50 * (1 - 2 * topDelta / overlayHeight) + \"%\";\r\n        arrowOffsetLeft = undefined;\r\n      } else if (nextPlacement === 'top' || nextPlacement === 'bottom') {\r\n        positionLeft = left + (childOffset.width - overlayWidth) / 2;\r\n        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container);\r\n        positionLeft += leftDelta;\r\n        arrowOffsetLeft = 50 * (1 - 2 * leftDelta / overlayWidth) + \"%\";\r\n        arrowOffsetTop = undefined;\r\n      }\r\n\r\n      if (nextPlacement === 'top' || nextPlacement === 'topStart' || nextPlacement === 'topEnd') {\r\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top - overlayHeight);\r\n      }\r\n\r\n      if (nextPlacement === 'bottom' || nextPlacement === 'bottomStart' || nextPlacement === 'bottomEnd') {\r\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top + childOffset.height);\r\n      }\r\n\r\n      if (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd') {\r\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left - overlayWidth);\r\n      }\r\n\r\n      if (nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd') {\r\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left + childOffset.width);\r\n      }\r\n\r\n      if (document.dir === 'rtl' && (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd' || nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd')) {\r\n        /**\r\n         * When laying out in rtl, if the width of the container\r\n         * is less than the width of the container scrolling,\r\n         * you need to recalculate the left value.\r\n         */\r\n        var _getContainerDimensio4 = getContainerDimensions(container),\r\n            containerWidth = _getContainerDimensio4.width;\r\n\r\n        if (container.scrollWidth > containerWidth) {\r\n          positionLeft = containerWidth + positionLeft - container.scrollWidth;\r\n        }\r\n      }\r\n\r\n      if (nextPlacement === 'topStart' || nextPlacement === 'bottomStart') {\r\n        if (document.dir === 'rtl') {\r\n          var nextLeft = left + (childOffset.width - overlayWidth);\r\n          positionLeft = nextLeft + getLeftDelta(nextLeft, overlayWidth, container);\r\n        } else {\r\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\r\n        }\r\n      }\r\n\r\n      if (nextPlacement === 'topEnd' || nextPlacement === 'bottomEnd') {\r\n        if (document.dir === 'rtl') {\r\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\r\n        } else {\r\n          var _nextLeft = left + (childOffset.width - overlayWidth);\r\n\r\n          positionLeft = _nextLeft + getLeftDelta(_nextLeft, overlayWidth, container);\r\n        }\r\n      }\r\n\r\n      if (nextPlacement === 'leftStart' || nextPlacement === 'rightStart') {\r\n        positionTop = top + getTopDelta(top, overlayHeight, container);\r\n      }\r\n\r\n      if (nextPlacement === 'leftEnd' || nextPlacement === 'rightEnd') {\r\n        var nextTop = top + (childOffset.height - overlayHeight);\r\n        positionTop = nextTop + getTopDelta(nextTop, overlayHeight, container);\r\n      }\r\n\r\n      return {\r\n        positionLeft: positionLeft,\r\n        positionTop: positionTop,\r\n        arrowOffsetLeft: arrowOffsetLeft,\r\n        arrowOffsetTop: arrowOffsetTop,\r\n        positionClassName: \"placement-\" + kebabCase(nextPlacement)\r\n      };\r\n    }\r\n  };\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}